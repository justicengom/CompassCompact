## Gorm4 - PileupReader
#
# This class abstracts a mpileup file generated by samtools
# It indexes the file and allows accessing at any random position given
# the contigsId + the position, if it does not exist it will return None
#
# timings, mpileup file (3897741 records, 4290252 positions)
#
# Indexing: 23 Seconds
# Iterating over all the records with getRecord(): 25 seconds
# Total time 48 secs
#
# ============================================================================ #
# Carlos del Ojo Elias
# carlos.delojoelias@ndm.ox.ac.uk
# Juny 2013
# ============================================================================ #

from bigtxtfile import *
from extendibleArray import *
import itertools
import struct
import re


class PileupReader(BigTxtFile):
    reNumber = re.compile("\d+")

    fld_REF = 0
    fld_POS = 1
    fld_REFBASE = 2
    fld_COV = 3
    fld_SPFBASES = 4
    fld_QUALS = 5

    def __init__(self, fil, index=False):
        self.indexing = index
        self.indexData = {}
        BigTxtFile.__init__(self, fil)

    def _initialise(self):
        if self.indexing:
            self.fp.seek(0)
            pos = 0
            for i in self.fp:
                parts = i[:-self.lenCR].split()
                if parts:
                    if not parts[0] in self.indexData:
                        self.indexData[parts[0]] = ExtendibleArray(
                            'l', defvalue=-1)
                    self.indexData[parts[0]].insert(int(parts[1]), pos)
                pos += len(i)

    def getRecord(self, contig, pos):
        try:
            self.fp.seek(self.indexData[contig][pos])
            return self.fp.readline()[:-self.lenCR].split()
        except:
            return None

    def __contains__(self, tupl):
        contig, pos = tupl
        return contig in self.indexData and pos <= (len(self.indexData[contig]) + 1) and pos < len(
            self.indexData[contig]) and self.indexData[contig][pos] >= 0

    def basesAndQuals(self, contig, pos):
        """
        Convert a string in simplified pileup format (spf), and as output.bam by samtools mpileup
        non-BCF output.bam, and return either an empty string on error or the DNA nucleotide
        version of the string. The calling fn must check if the length of the cleaned up
        DNA sequence is correct.

        Pattern	   Interpretation

        .			 A match to the reference base on the forward strand (upper case)
        ,			 A match to the reference base on the reverse strand (lower case)
        ACGTN		 A variant on the forward strand.
        acgtn		 A variant on the reverse strand.
        $			 Indicates the end of a read. These are removed.
        *			 A padding character indicating that there is a read that spans
                      this reference position but it's a gap in the sample. The readcoverage
                      field in the mpileup output.bam still counts these reads so the only way
                      to get the readcoverage value to match with the length of the cleaned
                      up base value is to not remove the * character from the mpileup bases
                      string. I don't understand why a base of '*' has a base quality but
                      I'm assuming it must since the counts match up when I leave these '*'s in.
        \+[0-9]+[ACGTNacgtn]+  An insertion between this reference pos and the next
                      In a tview window, these would be * in the reference.
        \-[0-9]+[ACGTNacgtn]+  A deletion between this reference pos and the next.
                      In a tview window, these would be * in the sample read.
        ^Mcigar	   Marks the start of a read segment which is a contiguous
                      subsequence on the read separated by 'N/S/H' CIGAR operations.
                      The ASCII of the character following '^'-33 gives the mapping quality.

        Warning: I have not implemented the 'cigar' part of '^Mcigar'. I'm hoping that
        none of our input data files has these.

        Once all of these are left, what we have is the column of bases that map
        to the reference position only.

        For more information on how this works, see:
        * The SAMtools pileup specification
          http://samtools.sourceforge.net/pileup.shtml
        * The SAMtools format and software paper by Li et al, 2009
          http://bioinformatics.oxfordjournals.org/content/25/16/2078.full
        * A discussion on SeqAnzwers was also quite helpful but I didn't save the link

        This was not implemented using tricky list comprehensions because there
        were too many filters to implement and I felt that it would actually be
        faster to do things with only one iteration through the input string.
        [CI 10-Mar-2012]
        """

        record = self.getRecord(contig, pos)
        if not record:
            return []

        # We want this fn to be fast, so minimise all unnecessary computation.
        refbase = record[self.fld_REFBASE]
        quals = struct.unpack(
            "b" * len(record[self.fld_QUALS]), record[self.fld_QUALS])
        quals = [i - 33 for i in quals]
        spfseq = record[self.fld_SPFBASES]

        reffwd = refbase.upper()
        refrev = refbase.lower()
        # Create the new dnaseq and return it.
        dnaseq = []
        i = 0
        spfseqlen = len(spfseq)
        while i < spfseqlen:
            if spfseq[i] == '.':
                dnaseq.append(reffwd)
            elif spfseq[i] == ',':
                dnaseq.append(refrev)
            elif spfseq[i] == '^':
                i += 1
            elif spfseq[i] in '+-':
                numberpart = self.reNumber.search(spfseq[i + 1:])
                if numberpart:
                    i += len(numberpart.group()) + int(numberpart.group())
            elif spfseq[i] != '$':
                dnaseq.append(spfseq[i])
            i += 1

        return itertools.izip(dnaseq, quals)


if __name__ == '__main__':
    a = PileupReader(
        "tmp/C00002880_R00000003.mapcall.3.mpileup.txt", index=True)
    j = 0
    for i in xrange(4290252):
        if a.getRecord("R00000003", i):
            j += 1

    import code

    code.interact(local=locals())
